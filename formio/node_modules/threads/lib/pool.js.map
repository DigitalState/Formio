{"version":3,"sources":["pool.js"],"names":["Pool","threads","options","spawn","pool","size","idleThreads","slice","jobQueue","runArgs","on","job","handleNewJob","dequeue","run","args","send","Error","killAll","forEach","thread","kill","queueJob","push","length","shift","once","handleJobSuccess","handleJobError","executeOn","responseArgs","emit","handleJobDone","error","destroy","setTimeout","threadCount","threadIndex"],"mappings":"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","file":"pool.js","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport Job          from './job';\nimport defaults     from './defaults';\nimport { spawn }    from './';\n\nexport default class Pool extends EventEmitter {\n  constructor(threads, options = {}) {\n    super();\n    this.threads = Pool.spawn(threads || defaults.pool.size, options);\n    this.idleThreads = this.threads.slice();\n    this.jobQueue = [];\n    this.runArgs = [];\n\n    this.on('newJob', (job) => this.handleNewJob(job));\n    this.on('threadAvailable', () => this.dequeue());\n  }\n\n  run(...args) {\n    this.runArgs = args;\n    return this;\n  }\n\n  send(...args) {\n    if (!this.runArgs) {\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\n    }\n\n    const job = new Job(this);\n    return job.run(...this.runArgs).send(...args);\n  }\n\n  killAll() {\n    this.threads.forEach(thread => {\n      thread.kill();\n    });\n  }\n\n  queueJob(job) {\n    this.jobQueue.push(job);\n    this.dequeue();\n  }\n\n  dequeue() {\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\n      return;\n    }\n\n    const job = this.jobQueue.shift();\n    const thread = this.idleThreads.shift();\n\n    job\n      .once('done', (...args) => this.handleJobSuccess(thread, job, ...args))\n      .once('error', (...args) => this.handleJobError(thread, job, ...args));\n\n    job.executeOn(thread);\n  }\n\n  handleNewJob(job) {\n    job.once('readyToRun', () => this.queueJob(job));    // triggered by job.send()\n  }\n\n  handleJobSuccess(thread, job, ...responseArgs) {\n    this.emit('done', job, ...responseArgs);\n    this.handleJobDone(thread, job);\n  }\n\n  handleJobError(thread, job, error) {\n    this.emit('error', job, error);\n    this.handleJobDone(thread, job);\n  }\n\n  handleJobDone(thread, job) {\n    job.destroy();                    // to prevent memory leak\n    this.idleThreads.push(thread);\n    this.emit('threadAvailable');\n\n    if (this.idleThreads.length === this.threads.length) {\n      // run deferred to give other job.on('done') handlers time to run first\n      setTimeout(() => { this.emit('finished'); }, 0);\n    }\n  }\n}\n\nPool.spawn = (threadCount, options) => {\n  const threads = [];\n\n  for (let threadIndex = 0; threadIndex < threadCount; threadIndex++) {\n    threads.push(spawn(null, [], options));\n  }\n\n  return threads;\n};\n"]}